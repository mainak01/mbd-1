#!/usr/bin/env python
from __future__ import print_function
from optparse import OptionParser
from glob import glob
from contextlib import contextmanager
import os
import json
import stat
import sys
from distutils import sysconfig
if sys.version_info[0] == 2:
    from ConfigParser import ConfigParser
else:
    from configparser import ConfigParser


blddir = 'build'


@contextmanager
def cd(path):
    cwd = os.getcwd()
    os.chdir(path)
    try:
        yield
    finally:
        os.chdir(cwd)


def write_env(env, f):
    for varname, value in env.items():
        f.write('{0} = {1}\n'.format(varname, value))
    f.write('\n')


def configure(opts, env):
    config = ConfigParser()
    config.add_section('egg_info')
    config.set('egg_info', 'egg-base', 'egg')
    if not os.path.isdir('egg'):
        os.mkdir('egg')
    config.add_section('cffi')
    config.set('cffi', 'lapack', opts.lapack)
    config.set('cffi', 'library-dirs', blddir)
    config.add_section('fortran')
    config.set('fortran', 'mpifc', opts.mpifc)
    with cd('src'):
        fortran_files = glob('*.f90')
    srcdir_rel = os.path.relpath('src', blddir)
    fortran_tasks = {}
    fobjs = []
    for filename in fortran_files:
        stem, _ = os.path.splitext(os.path.basename(filename))
        objfile = stem + '.o'
        fobjs.append(objfile)
        filepath = os.path.join(srcdir_rel, filename)
        if filename == 'mbd_interface.f90':
            fc = opts.mpifc
        else:
            fc = opts.fc
        fortran_tasks[filename] = {
            'source': filepath,
            'args': fc.split() + ['-c', '-o', objfile] + opts.fflags.split()
        }
    with open('Makefile.in') as f:
        makefile = f.read()
    env.update({
        'BLDDIR': blddir,
        'PYTHON': sys.executable,
    })
    with open('Makefile', 'w') as f:
        f.write('# Generated automatically by ./configure from Makefile.in\n\n')
        write_env(env, f)
        f.write(makefile)
    if not os.path.isdir(blddir):
        os.mkdir(blddir)
    with open('setup.cfg', 'w') as f:
        config.write(f)
    with open('build.mk') as f:
        makefile = f.read()
    env = {
        'FOBJS': ' '.join(fobjs),
        'VPATH': srcdir_rel,
    }
    with open(os.path.join(blddir, 'Makefile'), 'w') as f:
        write_env(env, f)
        f.write(makefile)
    with open(os.path.join(blddir, 'fcompile.json'), 'w') as f:
        json.dump(fortran_tasks, f)


def get_defaults():
    opts = {
        'fc': 'gfortran',
        'mpifc': 'mpifort',
        'fflags': sysconfig.get_config_var('CCSHARED')
    }
    if sys.platform == 'darwin':
        opts.update({'lapack': '-framework Accelerate'})
    elif sys.platform.startswith('linux'):
        opts.update({'lapack': '-llapack -lblas'})
    return opts


def main(argv=sys.argv[1:]):
    opts = get_defaults()
    parser = OptionParser(usage='usage: ./configure [options] [VAR=VAL...]')
    parser.add_option('--lapack', default=opts.get('lapack'), help='build directory [default: %default]')
    parser.add_option('--fc', default=opts.get('fc'), help='Fortran compiler [default: %default]')
    parser.add_option('--mpifc', default=opts.get('mpifc'), help='MPI Fortran compiler [default: %default]')
    parser.add_option('--fflags', default=opts.get('fflags'), help='Fortran flags [default: %default]')
    opts, args = parser.parse_args(argv)
    assert opts.lapack
    env = dict(arg.split('=', 1) for arg in args)
    configure(opts, env)


config_status = """\
#!{executable}
import imp

configure = imp.new_module('configure')
with open('./configure') as f:
    exec(compile(f.read(), 'configure', 'exec'), configure.__dict__)
configure.main({argv!r})
"""

if __name__ == '__main__':
    if not (len(sys.argv) == 2 and sys.argv[1] in ['-h', '--help']):
        with open('config.status', 'w') as f:
            f.write(config_status.format(
                executable=sys.executable,
                argv=sys.argv[1:]
            ))
        os.chmod('config.status', os.stat('config.status').st_mode | stat.S_IEXEC)
    main()
